1. 面向对象编程
    含义：通过交互作用来完成特定功能的对象的集合
    特点：通过继承、封装、多态等方法降低程序的耦合度 易修改、扩展、和复用
    特征：封装、继承、多态

    1：访问是对属性关闭，对方法开放
    2: 指针成员在构造函数中申请 析构函数中释放
    3：类中有指针成员要写拷贝构造和赋值运算符重载的深拷贝  防止造成二次double free
    4: 类对扩展开放 对修改关闭

2. 类(class) 不占用内存空间
    class   xxxxxx
    里面不仅可以包含变量还可以有函数

    2：结构体和类的区别：
    结构体定义出的变量还称为：变量 
    类定义出来的变量称为：对象（类的实例 占用内存空间）

    class 和struct 的区别：默认的访问权限不同
    class :默认私有
    struct :默认公有


3. 类的访问控制（权限）
   1: public:
            公有属性 不管是类的外部还是内部都可以访问  定义函数 也可以定义变量 

   2:protected:
            保护属性 只能在类的内部访问  

   3:private:
            私有属性 只能在类的内部访问  定义变量  
    类内声明，类外定义；


4. 构造函数和析构函数
    
    构造函数： 初始化对象状态的函数   不需要手动调用
    名字和类的名字相同 没有返回值 不需要用户自己调用在创建对象时自动执行
    一个类必须的有构造函数 要么用户自己定义，要么编译器自动生成
    1：规则：
            1、构造函数的名称必须和类的名称相同
            2、构造函数不能有返回值，函数体中不能有return语句
            3、在定义对象时会自动执行，不需要手动调用

    2：构造函数的重载
    重载的规律： 1、参数类型不一样
                2、参数数量不一样
                3、参数顺序不一样

    3：构造函数的调用方法
                * 1：括号法   // Test t1(10);  t1.print();  
                * 2：等号法 （只能调用单个参数的构造函数 ） // Test t2 = (1, 2) == Test t2 = 2;
                * 3: 手动调用 // Test t1 =Test(10) ;   t1.print();
4.1. 拷贝构造
    参数必须的是对象的引用
    Student(const Student & stu)

    赋值运算符的重载函数
    2、浅拷贝：
            当类中含有指针属性时，如果用拷贝构造，拷贝的是指针的值，
            使得两个对象的指针指向同一块内存 析构释放时候发生二次释放

    3、深拷贝：内存复制
            

RVO 优化： return value optimizer： 返回值优化   优化掉不需要的拷贝构造的过程





5. 析构函数
    不需要手动调用
    函数形式： ~ Student();
    销毁对象时系统自动调用一个函数进行释放分配的内存、关闭打开的文件
    没有参数 不能被重载 一个类只能有一个析构函数 用户没有定义则系统自动分配



6. 构造函数的参数的初始化列表
    规则：
        1：初始化列表要比当前对象的构造函数先执行
        2：子对象的初始化顺序 与类的声明顺序有关 先声明先初始化
        3：析构函数的调用顺序与构造函数相反
        4：初始化const成员变量的唯一方法就是使用参数初始化表

7. 浅拷贝和深拷贝
    1：浅拷贝
    默认拷贝为浅拷贝无法复制在堆上开辟的空间，只对数据进行简单的复制
    2：深拷贝
    进行堆上空间的复制

8. 静态成员变量和静态成员函数  

   /* 不允许字符串常量转化为非常量指针 */


******************************************************************************************************

*****
9. new & delete 和 malloc & free的区别
    1、new .... 是关键字 malloc... 是函数 （本质 ）
    2、不需要计算内存大小 不需要判断指针是否为空（抛出异常 终止程序）  不需要转化指针 （使用形式）
    3、new ... 会调用构造和析构函数  malloc ... 不会 （内存）


10. 关键字：
    explicit: 防止隐式转换   (重新赋值后  不会改变该值  且会报错  ) 
    public:
    /* 防止隐式转换 */
     explicit Interger(int a)
    todo ...
    Interger i (10);
    /* 构造函数的隐示转换： 数值会被隐式构造成类的对象*/
    // i = 20;
    std :: cout << i.getInterger() << std :: endl;



11. 初始化列表
    const:
    1、常成员变量必须在初始化列表中进行初始化
    2、普通成员变量也可以在列表中进行初始化
    3、初始化列表的操作快于构造函数的主体

    static: 
    描述的变量在全局区
    c语言：
        1、局部变量：延长生命周期， 只初始化一次 
        2、全局变量： 只在当前文件可见
        3、函数： 只在当前文件可使用
    c++
        1、修饰的成员变量：该变量不属于某一类的成员，而属于类，由该类的成员共享
        注意事项：
                1、初始化不由类的成员对象完成，而由类自己完成

        2、修饰成员函数：
                    该函数不属于某成员 而是由所有成员共享
                    不能访问普通类的变量 只能访问静态成员变量
    

12. 单例模式 全局只有一个对象的模式
    1:防止对象在外部创建  防止构造函数在外部调用  构造函数是对象的初始化函数
        构造函数的私有化
    2：构建一个静态接口给外部使用
    3：在静态接口中构建static 返回该变量指针

    static  Singlecton *Instance()
    {
        static Singlecton s;
        return &s;

    }

13. this指针 ： 指向本类的对象
    用法：   
    1：*this 获取本对象
    2：this-> 区别类成员和形参   （ this->a  类成员）
    3:静态函数本内使用this指针  静态函数不属于某一个对象 就没有内存 就不会有this

14. friend 关键字  友元函数 访问类的私有成员 
        友元类： 该类可以访问类的所有私有成员
        友元关系不能进行传递 是单向的

 /* 匿名对象(将亡值): 生命周期只有一行代码  将名字给它   */

 关键字在声明的时候使用 

 15. const 对成员函数的修饰：
    1: /* 修饰返回值指针 保护返回值 返回值不能修改  */
    const int * func()
    {
        return &a;
    }

   2: /* 保护引用形参  不能在函数内做修改  */
    void func2 (const int &a)
    {
        // a++;
    }

   3: /* 修饰整个函数 该函数不允许对成员变量做修改 */
   void func ()const 
    {
        // a++;
    }













          





