1. 为什么 重构 <<  >>  是友元函数 

    实现对类的私有成员的访问， 重载的输入和输出是直接访问类的私有成员变量，而 << >> 运算符不属于该类的成员函数 
    成为友元函数后则可以让函数体直接访问类的私有变量 增强了类的封装性  

2. 防止头文件重复包含的两种方法
    1： #ifndef __NAMESPACE_H
       #define _NAMESPACE_H
       #endif

    2： #pragma once



3. 为什么模板的声明放在.cpp 文件里面不能放在头文件里面
    编译的四个过程： 
    1： 预处理： 展开宏定义、包含头文件的内容、进行条件编译等操作，生成一个被修改过的源代码文件。
    2： 编译：  在这个阶段，编译器将预处理后的源代码翻译成汇编代码。它会对语法进行检查，生成中间代码或者汇编代码
    3： 汇编：  汇编器将汇编代码翻译成机器可执行的二进制指令。它将汇编代码转换为机器指令，并生成一个目标文件（.o）
    4： 链接：  在这个阶段，链接器将目标文件与其他的目标文件或者库文件进行链接，生成最终的可执行文件。  
1：链接出了问题 原因： 
    汇编在链接之前  汇编时call 后面为随机值； 在链接时未找到call后面的函数地址  因为模板没有被实例化  所以链接完成后 地址无法被更新  
2：汇编没有实例化 模板未被使用时 为被实例化

编译器在编译源文件时无法获取到定义，从而无法生成相应的代码，导致链接错误



4. free delete 释放资源后 都不会置为 NULL 需要手动释放  

智能指针 
5. auto_ptr 无法释放数组的资源

6. shared_ptr 多个可用于指向同一个对象 当最后一个shared_ptr作用结束后才会在内部实现自动释放资源 
        原理：
            1： 一个shared_ptr 会对一个对象产生强引用
            2：每个对象有个与之对应的强引用计数， 记录当前对象有多少个强引用 (use.count)
            3:当一个新的shared_ptr指向对象 对强引用计数就会+1；
            4：当一个新的shared_ptr销毁时 对强引用计数就会-1；
            5：当一个对象的强引用的计数为0时，对象机会自动销毁；
7. 循环引用

8. weak_ptr 解决shared_ptr 循环引用的问题
    不能初始化 


9. unique_ptr 也会对一个对象产生强引用 它可以确保同一时间只有1个指针指向对象
        当销毁时，（作用域结束时）其指向对象也就自动销毁了
    可以使用 std :: move 函数转移unique_ptr的所有权

    对象的所有权 都会被转移  只有p2结束后才能进行析构  
    且所有权转移后 p1还可以使用该类的所有对象
    std ::unique_ptr<Person> p2 = std :: move(p1);