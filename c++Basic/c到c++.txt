c++

1、对c的1兼容:所有的c语言程序都是标准的c++程序
2、后缀
3、标准输入输出流头文件的改变
4、g++

c++的升级

名字控制：
1、:: :域解析符
2、namespace:命名空间 （函数、变量）
3、using 声明后面的符号可用
4、std :c++标准命名空间

更严格的类型控制
计算机的位操作最小的值：比特位
1、enum加强
2、bool:布尔类型 判断真假  赋值非0值都是1
3、const int *p = &a；常量指针：指针指向一个常量 内存不能修改
int * const p2 = &a；指针常量：指针是一个常量，指针不能变
数组指针：数组指针是指向数组的指针，
它指向数组的首地址，并且可以通过指针进行数组的访问。例如，int *arrPtr 就是一个指向整型数组的指针。
指针数组：指针数组是一个数组，其中的每个元素都是指针。
这意味着指针数组中存储的是指针，而不是实际的数据。
例如，int *ptrArr[10] 就是一个包含 10 个整型指针的数组。

函数指针：函数指针指向函数的指针。
通过函数指针，可以动态地调用不同的函数。
例如，int (*funcPtr)(int, int) 是一个指向以两个整型参数并返回整型结果的函数的指针。

指针数组：即一个数组，其中的每个元素都是指针。

运算符加强
3、三目运算符的加强：? :
4、C语言中三目运算符的返回结果是值
c++返回变量本身


关键字加强
const 真常量

const和#define 
1、const被命名空间约束，define作用与全局
2、const有明确的数据类型定义，define没有

struct加强
结构体本身的名字就作为类型
内部可以定义函数


指针的加强:

变量名：内存的标识
指针：内存的地址
引用：内存的别名
本质：指针常量
int &b = a；
int *const b = &a；

引用代码会在编译的时候会被替换成指针常量

注意事项：
1、要定义时初始化
2、初始化以后不再改变朝向
3、本质是指针常量，编译期替换
4、sizeof引用就是sizeof原变量

左值和右值
1、左值：有内存的值
2、右值：没有内存的值

const int &a：常引用 解决右值没有办法传递给左值引用的问题


函数加强：
1、内联函数

内联规则：
1、不要有循环
2、条件分支太多
3、不能取函数地址
4、不能有递归
。。。

2.默认参数
1、在函数声明的时候使用添加默认参数 ：int c = 0 
2、默认参数必须放在参数列表的末尾
3、默认参数的后百年全部都是默认参数

3.函数重载(多态)
函数名相同， 函数定义不同

重载的规则：
1、参数类型不一样
2、参数数量不一样
3、参数顺序不一样


默认参树和占位参数的区别？

默认参数不能构成函数重载会有歧义（数量不确定）
占位参数可以构成重载（其数量是固定）

c和c++联合编译
extern “C”  关键字：以c语言的函数命名方式进行编译
{

} 

c和c++ 都能编译的方法：
#ifdef__cplusplus
extern "c"
{

#endif
    void func()

#ifdef__cplusplus
}
#endif

c++内存管理：
c语言的内存管理

数组空间的分配：

c++：new delete
对应:
新建    释放
new()  delete
new[]  delete[]

std:: string

类和对象




c和c++的联和编译

关键字： extern 
extern  "C" ： 以下代码以C的方式进行编译
{

}

让其可以进行c编译也可以c++ 编译



c++的内存管理

c++： new delete

对应
new() delete
new[] delete[]
